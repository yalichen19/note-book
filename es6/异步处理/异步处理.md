# 异步处理

## 事件循环
js 运行的环境称为宿主环境
- 执行栈： call stack 一个数据结构，用于存放各种函数的执行环境，每一个函数执行之前，它的相关信息会加入到执行栈；函数调用之后，销毁执行环境。
- js 引擎永远执行的是执行栈的最顶部
- 异步函数：某些函数不会立即执行，需要等到某个事件达到才会执行，这样的函数称为异步函数，比如事件处理函数、异步函数的执行事件，会被宿主环境控制。

浏览器宿主环境包含5个线程：
1. js 引擎： 负责执行执行栈的最顶部代码
2. GUI 线程： 负责渲染页面
3. 事件监听线程： 负责监听各种事件
4. 计时线程：负责计时
5. 网络线程： 负责网络通信

当上面的线程发生了某些事情，如果该线程发现，这件事情有处理程序，它会将处理程序加入一个叫做事件队列的内存，当js引擎发现，执行栈中没有任何内容后，会将事件队列中的第一个函数加入执行栈中执行。

js引擎对事件队列的取出执行方式，以及与宿主环境的配合，称之为事件循环。

事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列为两种：
- 宏任务（macroTask）：计时器结束的回调、事件的回调、http回调等绝大部分异步函数进入宏队列
- 微任务（MutationObserver）Promise 产生的回调进入微队列

MutationObserver 用于监听某个 dom 对象的变化
当执行栈清空时，JS 引擎首先会将微任务中的所有任务以此执行结束，如果没有微任务，执行宏任务

## 事件和回调函数的缺陷

1. 回调地狱：某个异步操作需要等待之前的异步操作完成，无论用回调还是事件，都会陷入不断的嵌套
2. 异步之间的联系：某个异步操作要等待多个异步操作的结果，对这种联系的处理，会让代码的复杂度剧增


## Promise的基本使用
```js
const pro = new Promise((resolve, reject)=>{
  // 未决阶段的处理
  // 通过调用resolve函数将Promise推向已决阶段的resolved状态
  // 通过调用reject函数将Promise推向已决阶段的rejected状态
  // resolve和reject均可以传递最多一个参数，表示推向状态的数据
})

pro.then(data=>{
  //这是thenable函数，如果当前的Promise已经是resolved状态，该函数会立即执行
  //如果当前是未决阶段，则会加入到作业队列，等待到达resolved状态后执行
  //data为状态数据
}, err=>{
  //这是catchable函数，如果当前的Promise已经是rejected状态，该函数会立即执行
  //如果当前是未决阶段，则会加入到作业队列，等待到达rejected状态后执行
  //err为状态数据
})
```

细节：
1. 未决阶段的处理函数是同步的，会立即执行
2. thenable 和 catchable 函数是异步的，就算是立即执行，也会先加入到事件队列中等待执行，并且加入的队列是微队列
3. pro.then 可以只添加 thenable 函数，pro.catch 可以单独添加catchable 函数
4. 在未决阶段的处理函数中，如果发生未捕获的错误，会将状态推向rejected，并会被catchable 捕获
5. 一旦状态推向已决阶段，无法再对状态修改
6. Promise 并没有消除回调，只是让回调变得可控

## Promise 的串联
当后续 Promise 需要之前的 Promise 的处理结果时，需要 Promise 的串联

Promise 对象中，无论是 then 方法 还是 catch 方法，它们都具有返回值，返回的是一个全新的 Promise 对象，它的状态满足下面的规则：

1. 如果当前的 Promise 是未决的，得到的新的 Promise 是挂起的状态
2. 如果当前的 Promise 是已决的， 会运行相应的后续函数，并将后续函数的处理结果作为 resolved 状态的数据，应用到新的 Promise 中，如果后续处理发生错误，则把返回值作为 rejected 状态的数据，应用到新的 Promise 中

后续的 Pormise 一定会等到前面的 Promise 有了后续结果后，才会变成已决状态

如果前面的 Promise 的后续处理，返回的是一个 Promise， 则返回的新的 Promise 状态和后续处理返回的 Promise 状态保持一致