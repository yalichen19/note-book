# 类型
##  基本类型
- number
- string
- bollean
- null undefined
- 数组
- object

默认情况 null 和 undefined 是其他所有类型的子类型，它们可以赋值给其他类型。一般通过配置中添加 `strictNullChecks: true`, 获得更严格的空类型检查，null 和 undefined 只能赋值给自身。

## 其他常用类型
- 联合类型：多种类型任选其一
    ```ts
    // 联合类型 和 类型推导
    function print(strOrNum: string | number) {
      if (typeof strOrNum === 'string') {
        console.log(strOrNum.length) // 识别出是 string 类型
      } else {
        console.log(strOrNum.toFixed(2)) // 识别出是 number 类型
      }
    }
    ```
    配合类型保护进行判断

    类型保护： 当对某个变量进行类型判断之后，在判断语句块中便能确定它的确切类型，typeof 可以触发类型保护

- void: 通常用于约束函数的返回值，表示没有返回值
    ```ts
    function func ():void {
      console.log('xxx')
    }
    ```
- never: 通常用于约束函数的返回值，表示该函数永远不会结束
    ```ts
    function throwError():never {
      throw new Error();
    }

    function alwaysDoSomething():never {
      while(true) {

      }
    }
    ```
- 字面量类型：使用一个值来约束
    ```ts
    let sex: '男' | '女'
    sex = '女'

    let emptyArr: []
    emptyArr = []

    let user: {
      name: string,
      age: number
    } // 一般较少使用，会使用 类型别名
    user = {
      name: 'xxx',
      age: 1
    }
    ```
- 元祖类型（Tuple）：一个固定长度的数组，并且数组的每一项的类型确定
    ```ts
    let fixArr: [string, number];
    fixArr = ['1', 3]
    ```
- any: any 类型可绕过类型检查
    ```ts
    let ccc:any
    ccc = '123'
    ccc = 3
    ```

## 类型别名
对已知的一些类型定义名称，便于复用，格式：
```ts
type User = {
  name: string,
  age: number,
  gender: '男' | '女'
}
```

## 函数的相关约束

- 函数重载：在函数实现之前，对函数调用的多种情况进行声明
    ```ts
    // 函数重载
    function combine(a:string, b: string): string;
    function combine(a:number, b: number): number;
    function combine(a: string | number, b: string | number): string | number {
      if (typeof a === 'string' && typeof b === 'string' ) {
        return a + b;
      } else if (typeof a === 'number' && typeof b === 'number' ) {
        return a * b;
      }
      // 不能让函数有返回 undeined 的情况，需要抛出异常
      throw new Error('a 和 b 必须是相同类型');
    }
    ```
- 可选参数：可以在某些参数名后加上问号，该参数可以不用传递，但是必须在参数列表的末尾
    ```ts
    function add(a: number, b:number, c?:number) {
      if (c) {
        return  a + b + c;
      } else {
        return a + b;
      }
    }
    ```

## 枚举

# 字面量的问题
- 在类型约束位置，会产生重复代码。这一点可以用类型别名解决
- 逻辑含义和真实值混淆，但需要修改真实值时，需要修改大量代码
- 字面量类型不会进入编译结果，无法操作，如遍历枚举

# 枚举
定义：

```ts
enum Gender {
  male = '男',
  female = '女',
}
```

特点：
- 枚举的字段值是字符串或数字
- 数字枚举值默认会自增，从 0 开始
- 被数字枚举约束的变量，可以直接赋值为数字

最佳实践：
- 不用在一个枚举中即出现字符串字段又出现数字字段
- 使用时使用枚举字段名称，而不是真实值
